{"version":3,"sources":["AjaxRequestsKiller.ts"],"names":[],"mappings":"AAAA;;;;;EAKE;;;;;IAgBF,IAAI,QAAQ,CAAC;IACb,IAAI,eAAe,CAAC;IAIP,QAAA,kBAAkB,GAAQ;QACnC,sBAAsB;QACtB,WAAW,EAAE;YACT,OAAO,QAAQ,CAAC;QACpB,CAAC;QAED,6BAA6B;QAC7B,kBAAkB,EAAE;YAChB,OAAO,eAAe,CAAC;QAC3B,CAAC;QAED,qBAAqB;QACrB,UAAU,EAAE,UAAS,WAAW;YAC5B,2BAA2B;YAC3B,mDAAmD;YACnD,2DAA2D;YAC3D,+CAA+C;YAC/C,QAAQ,GAAG,CAAC,CAAC,QAAQ,CAAC,cAAc,CAAC,CAAC;YAEtC,8EAA8E;YAC9E,eAAe,GAAG,EAAE,CAAC;YAErB,2DAA2D;YACrD,qBAAM,CAAC,YAAa,CAAC,UAAU,GAAG,CAAC,CAAC,IAAI,CAAC,qBAAM,CAAC,YAAY,CAAC,UAAU,EAAE,UAC3E,EAAE,EACF,KAAK,EACL,OAAO;gBAEP,qDAAqD;gBACrD,IAAI,OAAO,CAAC,QAAQ,EAAE;oBAClB,KAAK,CAAC,QAAQ,GAAG,OAAO,CAAC,QAAQ,CAAC;oBAClC,eAAe,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;iBAC/B;gBAED,8DAA8D;gBAC9D,EAAE,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;YAClD,CAAC,CAAC,CAAC;YAEH,uDAAuD;YACvD,6CAA6C;YAC7C,WAAW,CAAC,EAAE,CAAC,YAAY,EAAE;gBACzB,oCAAoC;gBACpC,0DAA0D;gBAC1D,QAAQ,CAAC,OAAO,CAAC,EAAE,CAAC,KAAK,EAAE;oBACvB,kCAAkC;oBAClC,CAAC,CAAC,IAAI,CAAC,eAAe,EAAE,UAAS,UAAe;wBAC5C,mEAAmE;wBACnE,kEAAkE;wBAClE,IAAI,QAAQ,IAAI,QAAQ,KAAK,UAAU,CAAC,QAAQ,EAAE;4BAC9C,IAAI,UAAU,CAAC,UAAU,KAAK,CAAC,EAAE;gCAC7B,+CAA+C;gCAC/C,oCAAoC;gCACpC,UAAU,CAAC,cAAc,GAAG,IAAI,CAAC;gCACjC,UAAU,CAAC,KAAK,EAAE,CAAC;6BACtB;4BAED,mDAAmD;4BACnD,kCAAkC;4BAClC,eAAe,GAAG,CAAC,CAAC,OAAO,CAAC,eAAe,EAAE,UAAU,CAAC,CAAC;yBAC5D;oBACL,CAAC,CAAC,CAAC;oBAEH,8CAA8C;oBAC9C,QAAQ,GAAG,CAAC,CAAC,QAAQ,CAAC,cAAc,CAAC,CAAC;gBAC1C,CAAC,CAAC,CAAC;YACP,CAAC,CAAC,CAAC;QACP,CAAC;KACJ,CAAC","file":"AjaxRequestsKiller.js","sourcesContent":["/*\n\tÂ© 2020 NetSuite Inc.\n\tUser may not copy, modify, distribute, or re-bundle or otherwise make available this code;\n\tprovided, however, if you are an authorized user with a NetSuite account or log-in, you\n\tmay use this code subject to the terms that govern your access and use.\n*/\n\n/// <amd-module name=\"AjaxRequestsKiller\"/>\n\n// Keeps trak of ongoing ajax requests and of url (or hash) changes,\n// so when the url changes it kills all pending ajax requests that other routers may have initiated.\n// It's important to note that not all ajax request are opened by the change of the url,\n// for that reason it's important that you tag those who do by adding a\n// killerId: AjaxRequestsKiller.getKillerId() to the request (collection.fetch\n// and model.fetch may trigger a request)\n\nimport * as _ from 'underscore';\nimport { jQuery } from '../../Core/JavaScript/jquery/JQueryExtras';\n\nimport Backbone = require('../../../Commons/Utilities/JavaScript/backbone.custom');\n\nlet killerId;\nlet lambsToBeKilled;\n\nexport type AjaxRequestsKiller = any;\n\nexport const AjaxRequestsKiller: any = {\n    // @method getKillerId\n    getKillerId: function() {\n        return killerId;\n    },\n\n    // @method getLambsToBeKilled\n    getLambsToBeKilled: function() {\n        return lambsToBeKilled;\n    },\n\n    // @method mountToApp\n    mountToApp: function(application) {\n        // Sets the first Killer ID\n        // Every time the url changes this will be reseted,\n        // but as we are the last listening to the url change event\n        // this only happens after all request are made\n        killerId = _.uniqueId('ajax_killer_');\n\n        // Every time a request is made, a ref to it will be store in this collection.\n        lambsToBeKilled = [];\n\n        // Wraps the beforeSend function of the jQuery.ajaxSettings\n        (<any>jQuery.ajaxSettings).beforeSend = _.wrap(jQuery.ajaxSettings.beforeSend, function(\n            fn,\n            jqXhr,\n            options\n        ) {\n            // If the killerId is set we add it to the collection\n            if (options.killerId) {\n                jqXhr.killerId = options.killerId;\n                lambsToBeKilled.push(jqXhr);\n            }\n\n            // Finally we call the original jQuery.ajaxSettings.beforeSend\n            fn.apply(this, _.toArray(arguments).slice(1));\n        });\n\n        // We listen to the afterStart because Backbone.history\n        // is *potentialy* not ready until after that\n        application.on('afterStart', function() {\n            // There is a timing issue involved,\n            // the on all event happens after the 2nd requests is done\n            Backbone.history.on('all', function() {\n                // Check previous ongoing requests\n                _.each(lambsToBeKilled, function(prev_jqXhr: any) {\n                    // if the new id is different than the old one, it means that there\n                    // is a new killer id, so we kill the old one if its still ongoing\n                    if (killerId && killerId !== prev_jqXhr.killerId) {\n                        if (prev_jqXhr.readyState !== 4) {\n                            // If we are killing this request we don't want\n                            // the ErrorHandling.js to handle it\n                            prev_jqXhr.preventDefault = true;\n                            prev_jqXhr.abort();\n                        }\n\n                        // we take it off the lambsToBeKilled collection to\n                        // free some space and processing.\n                        lambsToBeKilled = _.without(lambsToBeKilled, prev_jqXhr);\n                    }\n                });\n\n                // Generates a new id for the **next** request\n                killerId = _.uniqueId('ajax_killer_');\n            });\n        });\n    }\n};\n"]}