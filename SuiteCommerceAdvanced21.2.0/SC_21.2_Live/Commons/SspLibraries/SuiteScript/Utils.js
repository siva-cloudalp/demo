/*
	Â© 2020 NetSuite Inc.
	User may not copy, modify, distribute, or re-bundle or otherwise make available this code;
	provided, however, if you are an authorized user with a NetSuite account or log-in, you
	may use this code subject to the terms that govern your access and use.
*/

// @module ssp.libraries
define('Utils', ['SC.Models.Init', 'underscore'], function(ModelsInit, _) {
    function _getColumnLabel(column) {
        const formula = column.getFormula();
        if (formula) {
            // if the column is a formula prefer the label
            // because the name is autogenerated: 'formulanumeric' or similar
            return column.getLabel() || column.getName();
        }
        return column.getName();
    }

    // @class Utils contain global utility methods from high level API for searching records, format currencies, record type meta information, etc
    var Utils = {
        // @function deepCopy Deep Copy of the object taking care of Backbone models
        // @param {Object} obj Object to be copy
        // @return {Object}
        deepCopy: function deepCopy(obj) {
            if (_.isFunction(obj) || this.isInstanceOfnlobjRecord(obj)) {
                return null;
            }

            let copy = {};
            const self = this;

            if (_.isArray(obj)) {
                copy = [];
                _.each(obj, function(value) {
                    !_.isFunction(value) && copy.push(self.deepCopy(value));
                });
            } else if (_.isObject(obj)) {
                for (let i = 0; i < Object.keys(obj).length; i++) {
                    const attr = Object.keys(obj)[i];
                    const value = obj[attr];
                    if (!_.isFunction(value) && _.isString(attr) && attr.indexOf('_') !== 0) {
                        copy[attr] = self.deepCopy(value);
                    }
                }
            } else {
                copy = obj;
            }

            return copy;
        },

        isInstanceOfnlobjRecord(record) {
            return (
                record &&
                !_.isString(record) &&
                !_.isNumber(record) &&
                !_.isBoolean(record) &&
                _.isFunction(record.getRecordType) &&
                _.isFunction(record.getId)
            );
        },

        // @method isDateType
        // @param {string}
        // @returns {Boolean}
        isDateType(field) {
            // Return true if the type of this field is expected to be date.
            return field === 'trandate' || field === 'createddate' || field === 'datecreated';
        },

        transformDateFormat(format) {
            // Format conversion
            // Suitescript value - moment value
            //
            // Date format
            // 	"fmMM/DDfm/YYYY" ~ MM/DD/YYYY
            // 	"fmDD/MMfm/YYYY" ~ DD/MM/YYYY
            // 	"fmDD-Monfm-YYYY" ~ DD-MMM-YYYY
            // 	"fmDD.MMfm.YYYY" ~ DD.MM.YYYY
            // 	"fmDD-MONTHfm-YYYY" ~ DD-MMMM-YYYY
            // 	"fmDD MONTHfm", YYYY ~ DD MMMM, YYYY
            // 	"YYYY-fmMM-DDfm" ~ YYYY-MM-DD
            // 	"DD/MM/YYYY" ~ DD/MM/YYYY
            // 	"DD-Mon-YYYY" ~ DD-MMM-YYYY
            // 	"DD-MONTH-YYYY" ~ DD-MMMM-YYYY
            //
            // LongDate Format
            // 	"fmDD Monthfm YYYY" ~ DD MMMM YYYY
            // 	"fmMonth DDfm, YYYY" ~ MMMM DD, YYYY
            //	"YYYY fmMonth DDfm" ~ YYYY MMMM DD
            // 	"Month DD, YYYY" ~ MMMM DD, YYYY
            // 	"DD Month YYYY" ~ DD MMMM, YYYY
            // 	"YYYY Month DD" ~ YYYY MMMM DD

            return format
                .toUpperCase()
                .replace('FMMM', 'MM')
                .replace('MMFM', 'MM')
                .replace('FMDD', 'DD')
                .replace('DDFM', 'DD')
                .replace('MONTHFM', 'MMMM')
                .replace('FMMONTH', 'MMMM')
                .replace('MONTH', 'MMMM')
                .replace('MONFM', 'MMM')
                .replace('FMMON', 'MMM')
                .replace('MON', 'MMM');
        },

        transformTimeFormat(format) {
            // Format conversion
            // Suitescript value - moment value
            // "fmHH:fmMI am" ~ hh:mm A
            // "fmHH24:fmMI" ~ HH:mm
            // "fmHH-fmMI am" ~ hh-mm A
            // "fmHH24-fmMI" ~ HH-mm
            // "MM" ~ mm
            return format
            .replace(/fmhh/i, 'hh')
            .replace(/fmh/i, 'hh')
            .replace(/h+/i, 'hh')
            .replace(/fmmi/i, 'mm')
            .replace(/hh24/i, 'HH')
            .replace(/mm/i, 'mm')
            .replace(/am/i, 'A')
            .replace('a', 'A');
        },

        // @method mapSearchResult
        // @param {Array<nlobjSearchColumn>}
        // @param {nlobjSearchColumn} apiElement columns
        // @returns {Object}
        mapSearchResult: function mapSearchResult(columns, apiElement) {
            const element = {};

            columns.forEach(function(column) {
                const col = column.searchColumn;
                const name = col.getName();
                const text = apiElement.getText(name, col.getJoin(), col.getSummary());
                const value = apiElement.getValue(name, col.getJoin(), col.getSummary());
                const has_function = col.getFunction();
                const { fieldName } = column;
                const is_datetype = Utils.isDateType(fieldName);

                // If this field is trandate, datecreated or createddate and has no functions associated, we apply the nlapiStringToDate
                //	function to convert this field in a date (ISO 8601 - https://www.w3.org/TR/NOTE-datetime).
                element[fieldName] =
                    is_datetype && !has_function ? nlapiStringToDate(value) : value;

                if (text) {
                    element[`${fieldName}_text`] = text;
                }
            });
            return element;
        },

        // @method mapSearchResults Extracts search results to a JSON-friendly format.
        // @param {Array<nlobjSearchColumn>} searchColumns
        // @param {Array<nlobjSearchResult>} searchResults
        // @return {Array<nlobjSearchResult>} mapped results
        // @private
        mapSearchResults: function mapSearchResults(searchColumns, searchResults) {
            if (!searchColumns || !searchResults) {
                return [];
            }

            const nameToCol = {}; // mapping columnName -> columns with that name
            const columns = []; // array of { searchColumn: (nlobjSearchColumn), fieldName: (name in result) }

            // detect columns with the same name
            _.each(searchColumns, function(col) {
                const name = _getColumnLabel(col);
                columns.push({
                    searchColumn: col
                });
                nameToCol[name] = (nameToCol[name] || 0) + 1;
            });
            // sets fieldNames for each column
            _.each(columns, function(column) {
                const { searchColumn } = column;
                const isANameClash = nameToCol[_getColumnLabel(searchColumn)] > 1;
                const coulumnJoim = searchColumn.getJoin();

                column.fieldName = _getColumnLabel(searchColumn);
                if (isANameClash && coulumnJoim) {
                    column.fieldName += `_${coulumnJoim}`;
                }
            });

            return searchResults.map(function(apiElement) {
                return Utils.mapSearchResult(columns, apiElement);
            });
        },

        // @method mapLoadResult
        // @param {Array<nlobjSearchColumn>} columns
        // @param {nlobjRecord} record
        // @return {Object}
        mapLoadResult: function mapLoadResult(columns, record) {
            const record_info = {};
            columns.forEach(function(name) {
                const value = record.getFieldValue(name);
                if (name === 'image' && !!value) {
                    const imageRecord = nlapiLoadFile(value);
                    if (imageRecord) {
                        record_info[name] = imageRecord.getURL();
                    } else {
                        record_info[name] = '';
                    }
                } else {
                    record_info[name] = value;
                }
            });
            return record_info;
        },

        loadAndExecuteSearch: function loadAndExecuteSearch(searchName, filters) {
            const savedSearch = nlapiLoadSearch(null, searchName);
            const filtersSS = savedSearch.getFilters();
            savedSearch.setFilterExpression(filters);
            savedSearch.addFilters(filtersSS);
            const runSearch = savedSearch.runSearch();
            const searchResults = runSearch.getResults(0, 1000);
            return Utils.mapSearchResults(savedSearch.getColumns(), searchResults);
        },

        // @method loadAndMapSearch
        // @param {String}searchName
        // @param {Array<nlobjSearchFilter>} filters
        // @return {Array<nlobjSearchResult>} mapped results
        loadAndMapSearch: function loadAndMapSearch(searchName, filters) {
            let savedSearch;
            filters = filters || [];

            try {
                savedSearch = nlapiLoadSearch(null, searchName);
            } catch (err) {
                console.log(`Unable to load search ${searchName}`, err);
                return [];
            }
            const searchResults = nlapiSearchRecord(null, searchName, filters);
            return Utils.mapSearchResults(savedSearch.getColumns(), searchResults);
        },

        /**
         * @method mapOptions @param {String} record_options
         */
        mapOptions: function mapOptions(record_options) {
            const options_rows = record_options.split('\u0004');
            const options_items = options_rows.map(function(row) {
                return row.split('\u0003');
            });
            const options = {};
            options_items.forEach(function(item) {
                options[item[0]] = {
                    name: item[0],
                    desc: item[2],
                    value: item[3]
                };
            });
            return options;
        },

        /**
         * @method makeid @param {Number} maxLength
         */
        makeid: function makeid(maxLength) {
            return Math.random()
                .toString(36)
                .substring(2, maxLength + 2 || 5);
        },

        /**
         * @method getMolecule
         * @param {nlobjRequest} request
         * @returns {String}
         *		''		system
         *		'f'		system.f
         *		'p'		system.p
         *		'na1.f'	system.na1.f
         */
        getMolecule: function getMolecule(request) {
            const regex = /https:\/\/system(.*)\.netsuite\.com/;
            const molecule = request.getURL().match(regex);
            return (molecule && molecule[1]) || '';
        },

        // @method formatReceiptCurrency @param {String|Number} value
        formatReceiptCurrency: function formatReceiptCurrency(value) {
            const parsedValue = parseFloat(value);
            if (parsedValue < 0) {
                if (value.substring) {
                    return `($ ${value.substring(1)})`;
                }

                return `($ ${value.toFixed(2).substring(1)})`;
            }

            return `$ ${parsedValue.toFixed(2)}`;
        },

        // @method sanitizeString Remove any HTML code form the string
        // @param {String} text String with possible HTML code in it
        // @return {String} HTML-free string
        sanitizeString(text) {
            return text
                ? text
                      .replace(/<br>/g, '\n')
                      .replace(/</g, '&lt;')
                      .replace(/\>/g, '&gt;')
                : '';
        },

        // @method formatCurrency @param {String} value @param {String} symbol
        formatCurrency(value, symbol) {
            let value_float;
            let beforeValue = true;

            if (!value || isNaN(value)) {
                value_float = parseFloat(0); // return value;
            } else {
                value_float = parseFloat(value); // return value;
            }

            const negative = value_float < 0;
            value_float = Math.abs(value_float);
            value_float = parseInt((value_float + 0.005) * 100, 10) / 100;

            let value_string = value_float.toString();
            let groupseparator = ',';
            let decimalseparator = '.';
            let negativeprefix = '(';
            let negativesuffix = ')';
            const settings =
                SC && SC.ENVIRONMENT && SC.ENVIRONMENT.siteSettings
                    ? SC.ENVIRONMENT.siteSettings
                    : {};

            if (settings.hasOwnProperty('groupseparator')) {
                groupseparator = settings.groupseparator;
            }

            if (settings.hasOwnProperty('decimalseparator')) {
                decimalseparator = settings.decimalseparator;
            }

            if (settings.hasOwnProperty('negativeprefix')) {
                negativeprefix = settings.negativeprefix;
            }

            if (settings.hasOwnProperty('negativesuffix')) {
                negativesuffix = settings.negativesuffix;
            }

            value_string = value_string.replace('.', decimalseparator);
            let decimal_position = value_string.indexOf(decimalseparator);

            // if the string doesn't contains a .
            if (!~decimal_position) {
                value_string += `${decimalseparator}00`;
                decimal_position = value_string.indexOf(decimalseparator);
            }
            // if it only contains one number after the .
            else if (value_string.indexOf(decimalseparator) === value_string.length - 2) {
                value_string += '0';
            }

            let thousand_string = '';
            for (let i = value_string.length - 1; i >= 0; i--) {
                // If the distance to the left of the decimal separator is a multiple of 3 you need to add the group separator
                thousand_string =
                    (i > 0 && i < decimal_position && (decimal_position - i) % 3 === 0
                        ? groupseparator
                        : '') +
                    value_string[i] +
                    thousand_string;
            }

            const { currencies } = ModelsInit.session.getSiteSettings(['currencies']);

            if (!symbol) {
                if (
                    typeof ModelsInit.session !== 'undefined' &&
                    ModelsInit.session.getShopperCurrency
                ) {
                    try {
                        symbol = ModelsInit.session.getShopperCurrency().symbol;
                    } catch (e) {}
                } else if (settings.shopperCurrency) {
                    symbol = settings.shopperCurrency.symbol;
                } else if (SC && SC.ENVIRONMENT && SC.ENVIRONMENT.currentCurrency) {
                    symbol = SC.ENVIRONMENT.currentCurrency.symbol;
                }

                if (!symbol) {
                    symbol = '$';
                }
            }

            let matchingcurrency;

            if (!isNaN(symbol)) {
                matchingcurrency = _.findWhere(currencies, {
                    internalid: symbol
                });
            } else {
                matchingcurrency = _.findWhere(currencies, {
                    symbol
                });
            }

            if (matchingcurrency) {
                beforeValue = matchingcurrency.symbolplacement == 1;
                symbol = matchingcurrency.symbol;
            }

            const aux = negative
                ? negativeprefix + thousand_string + negativesuffix
                : thousand_string;
            value_string = beforeValue ? symbol + aux : aux + symbol;

            return value_string;
        },

        isDepartmentMandatory(record) {
            if (record) {
                const field = record.getField('department');

                return field && field.mandatory;
            }
            const department_mandatory = this._getAccountingPreferenceField('DEPTMANDATORY');

            return department_mandatory === 'T';
        },

        isLocationMandatory() {
            const location_mandatory = this._getAccountingPreferenceField('LOCMANDATORY');

            return location_mandatory === 'T';
        },

        isClassMandatory() {
            const class_mandatory = this._getAccountingPreferenceField('CLASSMANDATORY');

            return class_mandatory === 'T';
        },

        isFulfillmentRequestEnabled() {
            return this.isFeatureEnabled('FULFILLMENTREQUEST');
        },

        isFeatureEnabled(feature) {
            return ModelsInit.context.getFeature(feature);
        },

        // @method isCheckoutDomain determines if we are in a secure checkout
        // domain or in a secure single domain environment
        // @return {Boolean} true if in checkout or in single domain
        isCheckoutDomain: function isCheckoutDomain() {
            return ModelsInit.session.isCheckoutSupported();
        },

        // @method isShoppingDomain determines if we are in shopping domain (secure or non secure)
        //  or in a secure single domain environment
        // @return {Boolean} true if in shopping or single domain
        isShoppingDomain: function isShoppingDomain() {
            return ModelsInit.session.isShoppingSupported();
        },

        // @method getShoppingDomain determines the shopping domain
        // @return {String} shopping domain
        getShoppingDomain: function getShoppingDomain() {
            return ModelsInit.session.getEffectiveShoppingDomain();
        },

        // @method isSingleDomain determines if we are in a single domain environment
        // @return {Boolean} true if single domain
        isSingleDomain: function isSingleDomain() {
            return this.isShoppingDomain() && this.isCheckoutDomain();
        },

        // @method isInShopping determines if we are in shopping ssp
        // @return {Boolean} true if in shopping domain, false if in checkout or myaccount
        isInShopping: function isInShopping(request) {
            return (
                this.isShoppingDomain() &&
                (request.getHeader('X-SC-Touchpoint') === 'shopping' ||
                    request.getParameter('X-SC-Touchpoint') === 'shopping')
            );
        },

        isHttpsSupported: function isHttpsSupported() {
            return ~ModelsInit.session
                .getSiteSettings(['touchpoints'])
                .touchpoints.home.indexOf('https');
        },

        // @method isInCheckout determines if we are in checkout ssp or my account ssp
        // @return {Boolean} true if in checkout domain
        isInCheckout: function isInCheckout(request) {
            const self = this;

            if (!self.isSingleDomain()) {
                return self.isCheckoutDomain();
            }
            const paypal_complete = ModelsInit.context.getSessionObject('paypal_complete') === 'T';
            const is_in_checkout =
                request.getHeader('X-SC-Touchpoint') === 'checkout' ||
                request.getHeader('X-SC-Touchpoint') === 'myaccount' ||
                request.getParameter('X-SC-Touchpoint') === 'checkout' ||
                request.getParameter('X-SC-Touchpoint') === 'myaccount';

            return self.isCheckoutDomain() && (is_in_checkout || paypal_complete);
        },

        // Not used for now because there is only Full permissions on accountingpreferences
        _isAccountingPreferenceEnabled(preference) {
            let accounting_preferences;

            try {
                accounting_preferences = nlapiLoadConfiguration('accountingpreferences');
            } catch (err) {
                // The operation requires "Accounting Preferences" permission.
                // Validation is ommited if the user doesn't have it.
                return;
            }

            return accounting_preferences.getFieldValue(preference) === 'T';
        },

        _getAccountingPreferenceField(preference) {
            try {
                const { context } = ModelsInit;
                const accounting_preferences = context.getPreference(preference);

                return accounting_preferences;
            } catch (err) {}
        },

        // @method toCurrency @param {String} amount @return {Number}
        toCurrency(amount) {
            const r = parseFloat(amount);

            return isNaN(r) ? 0 : r;
        },

        // @method recordTypeExists returns true if and only if the given record type name is present in the current account - useful for checking if a bundle is installed or not in this account.
        // @param {String} record_type_name @return{Boolean}
        recordTypeExists(record_type_name) {
            try {
                nlapiCreateSearch(record_type_name, null, [], []);
            } catch (error) {
                return false;
            }
            return true;
        },

        // @method recordTypeHasField returns true if and only if the given field_name exists on the given record_type_name.
        // @param {String} record_type_name @param {String} field_name @return {Boolean}
        recordTypeHasField(record_type_name, field_name) {
            try {
                nlapiLookupField(record_type_name, 1, field_name);
                return true;
            } catch (error) {
                return false;
            }
        },

        getTransactionType(internalid) {
            try {
                return nlapiLookupField('transaction', internalid, 'recordtype');
            } catch (error) {
                return '';
            }
        },

        // @method getItemOptionsObject Parse an item string options into an object
        // @param {String} options_string String containg all item options
        // @return {Utils.ItemOptionsObject} Returns an object with the properties: id, name, value, displayvalue and mandatory
        getItemOptionsObject(options_string) {
            const options_object = [];

            if (options_string && options_string !== '- None -') {
                const split_char_3 = String.fromCharCode(3);
                const split_char_4 = String.fromCharCode(4);

                _.each(options_string.split(split_char_4), function(option_line) {
                    option_line = option_line.split(split_char_3);
                    // @class Utils.ItemOptionsObject
                    options_object.push({
                        // @property {String} id
                        id: option_line[0], // OPTION INTERNAL ID (lowercase)
                        // @property {String} name
                        name: option_line[2], // OPTION LABEL
                        // @property {String} value
                        value: option_line[3], // TO REMOVE
                        // @property {String} displayValue
                        displayvalue: option_line[4], // TO REMOVE
                        // @property {String} mandatory
                        mandatory: option_line[1] // Boolean

                        // ,	value: {label: option_line[4], internalid: option_line[3]}
                    });
                    // @class Utils
                });
            }

            return options_object;
        },

        // @method setPaymentMethodToResult @param {nlobjRecord} record @param {Object} result
        setPaymentMethodToResult(record, result) {
            const paymentmethod = {
                type: record.getFieldValue('paymethtype'),
                primary: true,
                name: record.getFieldText('paymentmethod')
            };
            const ccnumber = record.getFieldValue('ccnumber');

            if (ccnumber) {
                paymentmethod.type = 'creditcard';

                paymentmethod.creditcard = {
                    ccnumber,
                    ccexpiredate: record.getFieldValue('ccexpiredate'),
                    ccname: record.getFieldValue('ccname'),
                    internalid: record.getFieldValue('creditcard'),
                    paymentmethod: {
                        ispaypal: 'F',
                        name: record.getFieldText('paymentmethod'),
                        creditcard: 'T',
                        internalid: record.getFieldValue('paymentmethod')
                    }
                };
            }

            if (record.getFieldValue('ccstreet')) {
                paymentmethod.ccstreet = record.getFieldValue('ccstreet');
            }

            if (record.getFieldValue('cczipcode')) {
                paymentmethod.cczipcode = record.getFieldValue('cczipcode');
            }

            if (record.getFieldValue('terms')) {
                paymentmethod.type = 'invoice';

                paymentmethod.purchasenumber = record.getFieldValue('otherrefnum');

                paymentmethod.paymentterms = {
                    internalid: record.getFieldValue('terms'),
                    name: record.getFieldText('terms')
                };
            }

            result.paymentmethods = [paymentmethod];
        },

        // @method trim Remove starting and ending spaced from the passed in string
        // @param {String} str
        // @return {String}
        trim: function trim(str) {
            return str.replace(/^\s+|\s+$/gm, '');
        },

        // @method stringEndsWith Indicate if the first string ends with the second one
        // @para {String} str Original string used to check it end
        // @param {String} suffix
        // @return {Boolean}
        stringEndsWith(str, suffix) {
            return str.indexOf(suffix, str.length - suffix.length) !== -1;
        },

        getPathFromObject(object, path, default_value) {
            if (!path) {
                return object;
            }
            if (object) {
                const tokens = path.split('.');
                let prev = object;
                let n = 0;

                while (!_.isUndefined(prev) && n < tokens.length) {
                    prev = prev[tokens[n++]];
                }

                if (!_.isUndefined(prev)) {
                    return prev;
                }
            }

            return default_value;
        },
        // @method setPathFromObject @param {Object} object @param {String} path a path with values separated by dots @param {Any} value the value to set
        setPathFromObject(object, path, value) {
            if (!path) {
                return;
            }
            if (!object) {
                return;
            }

            const tokens = path.split('.');
            let prev = object;

            for (let token_idx = 0; token_idx < tokens.length - 1; ++token_idx) {
                const current_token = tokens[token_idx];

                if (_.isUndefined(prev[current_token])) {
                    prev[current_token] = {};
                }
                prev = prev[current_token];
            }

            prev[_.last(tokens)] = value;
        },

        // @method getTodayDate @return {Date}
        getTodayDate() {
            this.today = this.today || new Date().getTime();
            return new Date(this.today);
        },

        removeSecondsFromDateTimeField: function removeSecondsFromDateTimeField(value) {
            if (value) {
                const aux = value.split(':');
                let result = `${aux[0]}:${aux[1]}`;

                if (aux.length === 3) {
                    const ampm = aux[2].split(' ')[1];
                    result += ` ${ampm}`;
                }

                return nlapiStringToDate(result);
            }
            return null;
        },

        // @method getCurrencyById Get currency by internalid
        // @return {Currency}
        getCurrencyById(currency_id) {
            let selected_currency;
            const siteSettings_currencies = ModelsInit.session.getSiteSettings(['currencies']);

            if (currency_id && siteSettings_currencies) {
                selected_currency = _.find(siteSettings_currencies.currencies, function(currency) {
                    return currency.internalid === currency_id;
                });
            }

            return selected_currency;
        },
        replaceNewLineByASpace(line) {
            return line ? line.replace(/[\r\n]+/g, ' ') : line;
        },

        isTrue(value) {
            return _.isBoolean(value) ? value : value === 'T';
        },

        isFalse(value) {
            return _.isBoolean(value) ? !value : value === 'F';
        },
		isAnnonymous: function() {
            return !ModelsInit.session.isLoggedIn2() && !ModelsInit.session.isRecognized();
        },
        flatten: function(elem){
            return (typeof  elem === "object") ? JSON.stringify(elem) : elem;
        }
    };

    return Utils;
});
